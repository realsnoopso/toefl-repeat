'use client';

import { useState, useRef, useCallback, useEffect } from 'react';
import { Exercise, PlayerState, AudioSegment } from '@/lib/types';
import { playBeep } from '@/lib/audio/beep';
import { AudioRecorder } from '@/lib/audio/recorder';
import { startSpeechRecognition } from '@/lib/audio/stt';
import { evaluateAttempt } from '@/lib/evaluation/scoring';
import { saveAttempt } from '@/lib/storage/localStorage';
import { saveRecording } from '@/lib/storage/recordingDB';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { DiffDisplay } from '@/components/DiffDisplay';
import { motion, AnimatePresence } from 'framer-motion';

// Import transcripts (generated by whisper)
let transcriptsData: Record<string, string[]> = {};
try {
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  transcriptsData = require('@/lib/data/transcripts.json');
} catch { /* will be empty until transcripts are generated */ }

/** Extract first sentence from whisper transcript (whisper often duplicates the repeated sentence) */
function extractFirstSentence(text: string): string {
  if (!text) return '';
  // Remove leading number+period patterns like "1." "3." "9."
  const cleaned = text.replace(/^\d+\.\s*/, '').trim();
  // Split on period followed by space+uppercase (sentence boundary)
  const match = cleaned.match(/^(.+?\.)\s+[A-Z]/);
  return match ? match[1].trim() : cleaned;
}

export function PracticeScreen({ exercise, onBack }: { exercise: Exercise; onBack: () => void }) {
  const [state, setState] = useState<PlayerState>('idle');
  const [currentTime, setCurrentTime] = useState(0);
  const [activeSegment, setActiveSegment] = useState(-1);
  const [recordingTime, setRecordingTime] = useState(0);
  const [lastResult, setLastResult] = useState<ReturnType<typeof evaluateAttempt> | null>(null);
  const [segmentScores, setSegmentScores] = useState<Record<number, number>>({});
  const [userTranscript, setUserTranscript] = useState('');
  const [liveTranscript, setLiveTranscript] = useState('');
  const [recordingUrl, setRecordingUrl] = useState<string | null>(null);
  const [isPlayingBack, setIsPlayingBack] = useState(false);

  const audioRef = useRef<HTMLAudioElement | null>(null);
  const recorderRef = useRef(new AudioRecorder());
  const sttRef = useRef<{ stop: () => void } | null>(null);
  const timerRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const startTimeRef = useRef(0);
  const checkIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);

  const segments = exercise.segments;

  // Cleanup
  useEffect(() => {
    return () => {
      audioRef.current?.pause();
      if (timerRef.current) clearInterval(timerRef.current);
      if (checkIntervalRef.current) clearInterval(checkIntervalRef.current);
    };
  }, []);

  // Find which segment we're in based on current time
  const findSegmentIndex = useCallback((time: number): number => {
    for (let i = 0; i < segments.length; i++) {
      if (time >= segments[i].start && time < segments[i].end + 0.5) return i;
    }
    return -1;
  }, [segments]);

  // Start or resume playback
  const play = useCallback((fromTime?: number) => {
    if (!audioRef.current) {
      audioRef.current = new Audio(exercise.audioUrl);
      audioRef.current.preload = 'auto';
    }
    const audio = audioRef.current;
    if (fromTime !== undefined) audio.currentTime = fromTime;

    setState('playing');

    // Monitor playback for auto-pause at segment boundaries
    if (checkIntervalRef.current) clearInterval(checkIntervalRef.current);
    checkIntervalRef.current = setInterval(() => {
      const t = audio.currentTime;
      setCurrentTime(t);
      const segIdx = findSegmentIndex(t);
      if (segIdx >= 0) setActiveSegment(segIdx);

      // Check if we've hit a segment end point
      for (let i = 0; i < segments.length; i++) {
        const seg = segments[i];
        if (t >= seg.end - 0.05 && t < seg.end + 0.3) {
          // Check if this segment hasn't been paused at yet
          if (state === 'playing' || audio.paused === false) {
            audio.pause();
            setActiveSegment(i);
            setState('paused');
            if (checkIntervalRef.current) clearInterval(checkIntervalRef.current);
            return;
          }
        }
      }

      // Check if audio ended
      if (audio.ended) {
        setState('finished');
        if (checkIntervalRef.current) clearInterval(checkIntervalRef.current);
      }
    }, 50);

    audio.play().catch(() => setState('idle'));
  }, [exercise, findSegmentIndex, segments, state]);

  // Start recording at current segment
  const startRecording = useCallback(async () => {
    setState('recording');
    setRecordingTime(0);
    setUserTranscript('');
    setLiveTranscript('');
    startTimeRef.current = Date.now();
    
    await playBeep(800, 0.3);
    
    try {
      await recorderRef.current.start();
      // Start speech recognition
      sttRef.current = startSpeechRecognition(
        (transcript) => { setLiveTranscript(transcript); },
        () => {} // ignore errors silently
      );
      timerRef.current = setInterval(() => {
        setRecordingTime((Date.now() - startTimeRef.current) / 1000);
      }, 100);
    } catch {
      setState('paused');
    }
  }, []);

  // Stop recording and evaluate
  const stopRecording = useCallback(async () => {
    if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; }
    
    // Stop STT
    if (sttRef.current) { sttRef.current.stop(); sttRef.current = null; }
    
    const duration = (Date.now() - startTimeRef.current) / 1000;
    const transcript = liveTranscript;
    setUserTranscript(transcript);
    
    // Get recorded audio blob and create playback URL
    let blob: Blob | null = null;
    try { blob = await recorderRef.current.stop(); } catch { /* ignore */ }
    
    // Revoke previous URL
    if (recordingUrl) URL.revokeObjectURL(recordingUrl);
    
    // Get original text for this segment (first sentence only â€” whisper often duplicates)
    const origTexts = transcriptsData[exercise.id];
    const rawOrigText = origTexts?.[activeSegment] || '';
    const origText = extractFirstSentence(rawOrigText);
    
    const result = evaluateAttempt(exercise.id, exercise.titleKo, duration, transcript, activeSegment, origText);
    saveAttempt(result);

    if (blob && blob.size > 0) {
      const url = URL.createObjectURL(blob);
      setRecordingUrl(url);
      // Save to IndexedDB (backup)
      saveRecording({
        id: result.id,
        blob,
        mimeType: blob.type || 'audio/webm',
        timestamp: Date.now(),
        exerciseId: exercise.id,
        segmentIndex: activeSegment,
      }).catch(() => {});
      // Upload to server in background â€” save URL in attempt for sharing
      (async () => {
        try {
          const fd = new FormData();
          fd.append('attemptId', result.id);
          fd.append('file', blob, `${result.id}.webm`);
          const uploadRes = await fetch('/api/recording', { method: 'POST', body: fd });
          if (uploadRes.ok) {
            const { url: blobUrl } = await uploadRes.json();
            // Update the attempt in localStorage with the recording URL
            const key = 'toefl-repeat-attempts';
            const stored = JSON.parse(localStorage.getItem(key) || '[]');
            const idx = stored.findIndex((a: { id: string }) => a.id === result.id);
            if (idx >= 0) {
              stored[idx].recordingUrl = blobUrl;
              localStorage.setItem(key, JSON.stringify(stored));
            }
          }
        } catch { /* non-critical */ }
      })();
      // Auto-play recording
      const playback = new Audio(url);
      setIsPlayingBack(true);
      playback.onended = () => setIsPlayingBack(false);
      playback.onerror = () => setIsPlayingBack(false);
      playback.play().catch(() => setIsPlayingBack(false));
    } else {
      setRecordingUrl(null);
    }
    setLastResult(result);
    setSegmentScores(prev => ({ ...prev, [activeSegment]: result.scores.total }));
    setState('reviewing');
  }, [exercise, activeSegment, liveTranscript]);

  // Continue to next segment
  const continuePlayback = useCallback(() => {
    setLastResult(null);
    const seg = segments[activeSegment];
    if (seg && seg.resumeAt < exercise.duration - 0.5) {
      play(seg.resumeAt);
    } else {
      setState('finished');
    }
  }, [activeSegment, segments, exercise, play]);

  // Skip recording, just continue
  const skipSegment = useCallback(() => {
    setLastResult(null);
    const seg = segments[activeSegment];
    if (seg && seg.resumeAt < exercise.duration - 0.5) {
      play(seg.resumeAt);
    } else {
      setState('finished');
    }
  }, [activeSegment, segments, exercise, play]);

  // Jump to a specific segment
  const jumpToSegment = useCallback((idx: number) => {
    setLastResult(null);
    const seg = segments[idx];
    if (seg) {
      setActiveSegment(idx);
      play(seg.start);
    }
  }, [segments, play]);

  // Reset
  const reset = useCallback(() => {
    audioRef.current?.pause();
    if (audioRef.current) audioRef.current.currentTime = 0;
    setState('idle');
    setCurrentTime(0);
    setActiveSegment(-1);
    setLastResult(null);
  }, []);

  const progress = exercise.duration > 0 ? (currentTime / exercise.duration) * 100 : 0;

  return (
    <div className="h-full flex flex-col">
      {/* Header */}
      <header className="flex items-center gap-3 px-4 py-3 border-b border-border shrink-0">
        <button onClick={onBack} className="p-1 -ml-1">
          <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
          </svg>
        </button>
        <div className="min-w-0 flex-1">
          <h2 className="text-sm font-medium truncate">{exercise.titleKo}</h2>
          <p className="text-xs text-muted-foreground">{exercise.categoryKo} Â· {segments.length}ê°œ êµ¬ê°„</p>
        </div>
        <button
          onClick={async () => {
            const url = `${window.location.origin}?ex=${exercise.id}`;
            if (navigator.share) {
              try {
                await navigator.share({
                  title: `TOEFL ì—°ìŠµ - ${exercise.titleKo}`,
                  text: `${exercise.categoryKo} ${exercise.titleKo}`,
                  url,
                });
              } catch { /* user cancelled */ }
            } else {
              await navigator.clipboard.writeText(url);
              alert('ë§í¬ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
            }
          }}
          className="p-1.5 rounded-md hover:bg-muted transition-colors"
          title="ê³µìœ "
        >
          <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
          </svg>
        </button>
      </header>

      {/* Timeline bar */}
      <div className="px-4 py-2 border-b border-border shrink-0">
        <div className="relative h-8 bg-muted rounded-full overflow-hidden">
          {/* Progress */}
          <div className="absolute inset-y-0 left-0 bg-primary/20 transition-all" style={{ width: `${progress}%` }} />
          
          {/* Segment markers */}
          {segments.map((seg, i) => {
            const left = (seg.end / exercise.duration) * 100;
            const score = segmentScores[i];
            return (
              <button
                key={i}
                onClick={() => jumpToSegment(i)}
                className="absolute top-1/2 -translate-y-1/2 -translate-x-1/2 z-10"
                style={{ left: `${left}%` }}
                title={`êµ¬ê°„ ${i + 1}`}
              >
                <div className={`w-3 h-3 rounded-full border-2 transition-all ${
                  i === activeSegment ? 'border-primary bg-primary scale-125' :
                  score !== undefined ? (score >= 4 ? 'border-emerald-500 bg-emerald-500' : score >= 3 ? 'border-amber-500 bg-amber-500' : 'border-red-400 bg-red-400') :
                  'border-muted-foreground/30 bg-background'
                }`} />
              </button>
            );
          })}

          {/* Playhead */}
          <div className="absolute top-0 bottom-0 w-0.5 bg-primary transition-all" style={{ left: `${progress}%` }} />
        </div>
        <div className="flex justify-between text-[10px] text-muted-foreground mt-1">
          <span>{formatTime(currentTime)}</span>
          <span>{formatTime(exercise.duration)}</span>
        </div>
      </div>

      {/* Main content */}
      <div className="flex-1 flex flex-col items-center justify-center px-6 overflow-y-auto">
        <AnimatePresence mode="wait">
          {/* IDLE */}
          {state === 'idle' && (
            <motion.div key="idle" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
              className="flex flex-col items-center gap-6 w-full max-w-sm"
            >
              <div className="w-20 h-20 rounded-full bg-muted flex items-center justify-center">
                <span className="text-3xl">ğŸ§</span>
              </div>
              <div className="text-center">
                <p className="text-sm text-muted-foreground">ìŒì„± ì¬ìƒ â†’ êµ¬ê°„ë§ˆë‹¤ ìë™ ë©ˆì¶¤ â†’ ë…¹ìŒ</p>
                <p className="text-xs text-muted-foreground mt-1">íƒ€ì„ë¼ì¸ì˜ ë§ˆì»¤ë¥¼ í´ë¦­í•´ì„œ ì›í•˜ëŠ” êµ¬ê°„ìœ¼ë¡œ ì´ë™</p>
              </div>
              <Button onClick={() => play(0)} size="lg" className="w-full max-w-xs">
                â–¶ ì¬ìƒ ì‹œì‘
              </Button>
            </motion.div>
          )}

          {/* PLAYING */}
          {state === 'playing' && (
            <motion.div key="playing" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
              className="flex flex-col items-center gap-4"
            >
              <motion.div
                animate={{ scale: [1, 1.05, 1] }}
                transition={{ repeat: Infinity, duration: 2 }}
                className="w-20 h-20 rounded-full bg-primary/10 flex items-center justify-center"
              >
                <span className="text-3xl">ğŸ”Š</span>
              </motion.div>
              <p className="text-sm font-medium">ì¬ìƒ ì¤‘... êµ¬ê°„ {activeSegment + 1}/{segments.length}</p>
              <Button variant="outline" size="sm" onClick={() => {
                audioRef.current?.pause();
                setState('paused');
                if (checkIntervalRef.current) clearInterval(checkIntervalRef.current);
              }}>
                â¸ ì¼ì‹œì •ì§€
              </Button>
            </motion.div>
          )}

          {/* PAUSED (auto-pause at segment boundary) */}
          {state === 'paused' && !lastResult && (
            <motion.div key="paused" initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0 }}
              className="flex flex-col items-center gap-4 w-full max-w-sm"
            >
              <div className="text-center">
                <p className="text-xs text-muted-foreground mb-1">êµ¬ê°„ {activeSegment + 1} / {segments.length}</p>
                <p className="text-sm font-medium">ì´ êµ¬ê°„ì—ì„œ ë…¹ìŒí• ê¹Œìš”?</p>
              </div>
              <div className="flex gap-3 w-full">
                <Button onClick={startRecording} size="lg" className="flex-1">
                  ğŸ™ï¸ ë…¹ìŒí•˜ê¸°
                </Button>
                <Button onClick={skipSegment} variant="outline" size="lg" className="flex-1">
                  ê±´ë„ˆë›°ê¸° â†’
                </Button>
              </div>
              <Button variant="ghost" size="sm" className="text-xs" onClick={() => {
                const seg = segments[activeSegment];
                if (seg) play(seg.start);
              }}>
                ğŸ”„ ì´ êµ¬ê°„ ë‹¤ì‹œ ë“£ê¸°
              </Button>
            </motion.div>
          )}

          {/* RECORDING */}
          {state === 'recording' && (
            <motion.div key="recording" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
              className="flex flex-col items-center gap-6 w-full max-w-sm"
            >
              <motion.div
                animate={{ scale: [1, 1.15, 1], boxShadow: ['0 0 0 0 rgba(239,68,68,0)', '0 0 0 20px rgba(239,68,68,0.1)', '0 0 0 0 rgba(239,68,68,0)'] }}
                transition={{ repeat: Infinity, duration: 1.5 }}
                className="w-20 h-20 rounded-full bg-red-50 flex items-center justify-center"
              >
                <span className="text-3xl">ğŸ™ï¸</span>
              </motion.div>
              <div className="text-center">
                <p className="text-sm font-medium text-red-600">ë…¹ìŒ ì¤‘</p>
                <p className="text-2xl font-mono font-bold mt-1">{recordingTime.toFixed(1)}s</p>
                {liveTranscript && (
                  <p className="text-xs text-muted-foreground mt-2 italic max-w-xs">
                    &ldquo;{liveTranscript}&rdquo;
                  </p>
                )}
              </div>
              <Button onClick={stopRecording} variant="destructive" size="lg" className="w-full max-w-xs">
                â¹ ë…¹ìŒ ì¤‘ì§€
              </Button>
            </motion.div>
          )}

          {/* REVIEWING (showing result for this segment) */}
          {(state === 'reviewing' || (state === 'paused' && lastResult)) && lastResult && (
            <motion.div key="review" initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0 }}
              className="flex flex-col items-center gap-4 w-full max-w-sm"
            >
              <Card className="w-full p-5">
                <div className="text-center mb-3">
                  <p className="text-xs text-muted-foreground">êµ¬ê°„ {activeSegment + 1} ê²°ê³¼</p>
                  <p className={`text-4xl font-bold ${
                    lastResult.scores.total >= 4 ? 'text-emerald-600' :
                    lastResult.scores.total >= 3 ? 'text-amber-600' : 'text-red-600'
                  }`}>{lastResult.scores.total.toFixed(1)}</p>
                </div>
                <div className="space-y-2">
                  {[
                    { label: 'ì •í™•ë„', value: lastResult.scores.accuracy, color: 'bg-violet-500' },
                    { label: 'ì™„ì„±ë„', value: lastResult.scores.intelligibility, color: 'bg-emerald-500' },
                    { label: 'ìœ ì°½ì„±', value: lastResult.scores.fluency, color: 'bg-blue-500' },
                  ].map(s => (
                    <div key={s.label}>
                      <div className="flex justify-between text-xs mb-0.5">
                        <span className="text-muted-foreground">{s.label}</span>
                        <span className="font-medium">{s.value.toFixed(1)}</span>
                      </div>
                      <div className="h-1 bg-muted rounded-full overflow-hidden">
                        <motion.div
                          initial={{ width: 0 }}
                          animate={{ width: `${(s.value / 5) * 100}%` }}
                          transition={{ duration: 0.4 }}
                          className={`h-full rounded-full ${s.color}`}
                        />
                      </div>
                    </div>
                  ))}
                </div>
                <p className="text-xs text-center mt-3 text-muted-foreground">{lastResult.feedback}</p>
              </Card>
              {/* Diff display */}
              {(() => {
                const origTexts = transcriptsData[exercise.id];
                const origText = origTexts?.[activeSegment] ? extractFirstSentence(origTexts[activeSegment]) : undefined;
                if (origText && userTranscript) {
                  return (
                    <Card className="w-full p-4">
                      <p className="text-xs text-muted-foreground mb-2 font-medium">ë°œìŒ ë¹„êµ</p>
                      <DiffDisplay original={origText} spoken={userTranscript} />
                    </Card>
                  );
                }
                if (userTranscript) {
                  return (
                    <Card className="w-full p-4">
                      <p className="text-xs text-muted-foreground mb-1">ë‚´ê°€ ë§í•œ ê²ƒ</p>
                      <p className="text-sm">{userTranscript}</p>
                    </Card>
                  );
                }
                return null;
              })()}
              {/* Replay recording button */}
              {recordingUrl && (
                <Button
                  variant="ghost"
                  size="sm"
                  className="text-xs w-full"
                  disabled={isPlayingBack}
                  onClick={() => {
                    const audio = new Audio(recordingUrl);
                    setIsPlayingBack(true);
                    audio.onended = () => setIsPlayingBack(false);
                    audio.onerror = () => setIsPlayingBack(false);
                    audio.play().catch(() => setIsPlayingBack(false));
                  }}
                >
                  {isPlayingBack ? 'ğŸ”Š ì¬ìƒ ì¤‘...' : 'ğŸ” ë‚´ ë…¹ìŒ ë‹¤ì‹œ ë“£ê¸°'}
                </Button>
              )}
              <div className="flex gap-3 w-full">
                <Button onClick={() => { setLastResult(null); setRecordingUrl(null); startRecording(); }} variant="outline" className="flex-1 text-sm">
                  ë‹¤ì‹œ ë…¹ìŒ
                </Button>
                <Button onClick={continuePlayback} className="flex-1 text-sm">
                  ë‹¤ìŒ êµ¬ê°„ â†’
                </Button>
              </div>
            </motion.div>
          )}

          {/* FINISHED */}
          {state === 'finished' && (
            <motion.div key="finished" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
              className="flex flex-col items-center gap-4 w-full max-w-sm"
            >
              <span className="text-5xl">ğŸ‰</span>
              <p className="text-sm font-medium">ì—°ìŠµ ì™„ë£Œ!</p>
              {Object.keys(segmentScores).length > 0 && (
                <p className="text-xs text-muted-foreground">
                  ë…¹ìŒ {Object.keys(segmentScores).length}ê°œ êµ¬ê°„ Â· í‰ê·  {(Object.values(segmentScores).reduce((a, b) => a + b, 0) / Object.keys(segmentScores).length).toFixed(1)}ì 
                </p>
              )}
              <Button
                variant="ghost"
                size="sm"
                className="text-xs"
                onClick={async () => {
                  const url = `${window.location.origin}?ex=${exercise.id}`;
                  const scored = Object.keys(segmentScores).length;
                  const avg = scored > 0 ? (Object.values(segmentScores).reduce((a, b) => a + b, 0) / scored).toFixed(1) : '0';
                  const text = `ğŸ™ï¸ TOEFL ì—°ìŠµ ì™„ë£Œ!\n${exercise.titleKo} (${exercise.categoryKo})\nğŸ“Š ${scored}ê°œ êµ¬ê°„ Â· í‰ê·  ${avg}ì \n\në‚˜ë„ ì—°ìŠµí•˜ê¸° ğŸ‘‰ ${url}`;
                  if (navigator.share) {
                    try { await navigator.share({ title: 'TOEFL ì—°ìŠµ ê²°ê³¼', text }); } catch {}
                  } else {
                    await navigator.clipboard.writeText(text);
                    alert('ê²°ê³¼ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
                  }
                }}
              >
                ğŸ“¤ ê²°ê³¼ ê³µìœ í•˜ê¸°
              </Button>
              <div className="flex gap-3 w-full">
                <Button onClick={reset} variant="outline" className="flex-1">ì²˜ìŒë¶€í„°</Button>
                <Button onClick={onBack} className="flex-1">ëª©ë¡ìœ¼ë¡œ</Button>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>

      {/* Segment list (bottom) */}
      {state !== 'idle' && (
        <div className="border-t border-border px-4 py-2 shrink-0">
          <div className="flex gap-1.5 overflow-x-auto pb-1">
            {segments.map((_, i) => {
              const score = segmentScores[i];
              return (
                <button
                  key={i}
                  onClick={() => jumpToSegment(i)}
                  className={`shrink-0 w-8 h-8 rounded-md text-xs font-medium flex items-center justify-center transition-all ${
                    i === activeSegment ? 'bg-primary text-primary-foreground' :
                    score !== undefined ? (score >= 4 ? 'bg-emerald-100 text-emerald-700' : score >= 3 ? 'bg-amber-100 text-amber-700' : 'bg-red-100 text-red-700') :
                    'bg-muted text-muted-foreground'
                  }`}
                >
                  {score !== undefined ? score.toFixed(0) : i + 1}
                </button>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
}

function formatTime(seconds: number): string {
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60);
  return `${m}:${String(s).padStart(2, '0')}`;
}
