'use client';

import { useState, useRef, useCallback, useEffect } from 'react';
import { Exercise, PlayerState, AudioSegment } from '@/lib/types';
import { playBeep } from '@/lib/audio/beep';
import { AudioRecorder } from '@/lib/audio/recorder';
import { startSpeechRecognition } from '@/lib/audio/stt';
import { evaluateAttempt } from '@/lib/evaluation/scoring';
import { saveAttempt } from '@/lib/storage/localStorage';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { DiffDisplay } from '@/components/DiffDisplay';
import { motion, AnimatePresence } from 'framer-motion';

// Import transcripts (generated by whisper)
let transcriptsData: Record<string, string[]> = {};
try {
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  transcriptsData = require('@/lib/data/transcripts.json');
} catch { /* will be empty until transcripts are generated */ }

export function PracticeScreen({ exercise, onBack }: { exercise: Exercise; onBack: () => void }) {
  const [state, setState] = useState<PlayerState>('idle');
  const [currentTime, setCurrentTime] = useState(0);
  const [activeSegment, setActiveSegment] = useState(-1);
  const [recordingTime, setRecordingTime] = useState(0);
  const [lastResult, setLastResult] = useState<ReturnType<typeof evaluateAttempt> | null>(null);
  const [segmentScores, setSegmentScores] = useState<Record<number, number>>({});
  const [userTranscript, setUserTranscript] = useState('');
  const [liveTranscript, setLiveTranscript] = useState('');

  const audioRef = useRef<HTMLAudioElement | null>(null);
  const recorderRef = useRef(new AudioRecorder());
  const sttRef = useRef<{ stop: () => void } | null>(null);
  const timerRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const startTimeRef = useRef(0);
  const checkIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);

  const segments = exercise.segments;

  // Cleanup
  useEffect(() => {
    return () => {
      audioRef.current?.pause();
      if (timerRef.current) clearInterval(timerRef.current);
      if (checkIntervalRef.current) clearInterval(checkIntervalRef.current);
    };
  }, []);

  // Find which segment we're in based on current time
  const findSegmentIndex = useCallback((time: number): number => {
    for (let i = 0; i < segments.length; i++) {
      if (time >= segments[i].start && time < segments[i].end + 0.5) return i;
    }
    return -1;
  }, [segments]);

  // Start or resume playback
  const play = useCallback((fromTime?: number) => {
    if (!audioRef.current) {
      audioRef.current = new Audio(exercise.audioUrl);
      audioRef.current.preload = 'auto';
    }
    const audio = audioRef.current;
    if (fromTime !== undefined) audio.currentTime = fromTime;

    setState('playing');

    // Monitor playback for auto-pause at segment boundaries
    if (checkIntervalRef.current) clearInterval(checkIntervalRef.current);
    checkIntervalRef.current = setInterval(() => {
      const t = audio.currentTime;
      setCurrentTime(t);
      const segIdx = findSegmentIndex(t);
      if (segIdx >= 0) setActiveSegment(segIdx);

      // Check if we've hit a segment end point
      for (let i = 0; i < segments.length; i++) {
        const seg = segments[i];
        if (t >= seg.end - 0.05 && t < seg.end + 0.3) {
          // Check if this segment hasn't been paused at yet
          if (state === 'playing' || audio.paused === false) {
            audio.pause();
            setActiveSegment(i);
            setState('paused');
            if (checkIntervalRef.current) clearInterval(checkIntervalRef.current);
            return;
          }
        }
      }

      // Check if audio ended
      if (audio.ended) {
        setState('finished');
        if (checkIntervalRef.current) clearInterval(checkIntervalRef.current);
      }
    }, 50);

    audio.play().catch(() => setState('idle'));
  }, [exercise, findSegmentIndex, segments, state]);

  // Start recording at current segment
  const startRecording = useCallback(async () => {
    setState('recording');
    setRecordingTime(0);
    setUserTranscript('');
    setLiveTranscript('');
    startTimeRef.current = Date.now();
    
    await playBeep(800, 0.3);
    
    try {
      await recorderRef.current.start();
      // Start speech recognition
      sttRef.current = startSpeechRecognition(
        (transcript) => { setLiveTranscript(transcript); },
        () => {} // ignore errors silently
      );
      timerRef.current = setInterval(() => {
        setRecordingTime((Date.now() - startTimeRef.current) / 1000);
      }, 100);
    } catch {
      setState('paused');
    }
  }, []);

  // Stop recording and evaluate
  const stopRecording = useCallback(async () => {
    if (timerRef.current) { clearInterval(timerRef.current); timerRef.current = null; }
    
    // Stop STT
    if (sttRef.current) { sttRef.current.stop(); sttRef.current = null; }
    
    const duration = (Date.now() - startTimeRef.current) / 1000;
    const transcript = liveTranscript;
    setUserTranscript(transcript);
    
    try { await recorderRef.current.stop(); } catch { /* ignore */ }

    const result = evaluateAttempt(exercise.id, exercise.titleKo, duration, transcript, activeSegment);
    saveAttempt(result);
    setLastResult(result);
    setSegmentScores(prev => ({ ...prev, [activeSegment]: result.scores.total }));
    setState('reviewing');
  }, [exercise, activeSegment, liveTranscript]);

  // Continue to next segment
  const continuePlayback = useCallback(() => {
    setLastResult(null);
    const seg = segments[activeSegment];
    if (seg && seg.resumeAt < exercise.duration - 0.5) {
      play(seg.resumeAt);
    } else {
      setState('finished');
    }
  }, [activeSegment, segments, exercise, play]);

  // Skip recording, just continue
  const skipSegment = useCallback(() => {
    setLastResult(null);
    const seg = segments[activeSegment];
    if (seg && seg.resumeAt < exercise.duration - 0.5) {
      play(seg.resumeAt);
    } else {
      setState('finished');
    }
  }, [activeSegment, segments, exercise, play]);

  // Jump to a specific segment
  const jumpToSegment = useCallback((idx: number) => {
    setLastResult(null);
    const seg = segments[idx];
    if (seg) {
      setActiveSegment(idx);
      play(seg.start);
    }
  }, [segments, play]);

  // Reset
  const reset = useCallback(() => {
    audioRef.current?.pause();
    if (audioRef.current) audioRef.current.currentTime = 0;
    setState('idle');
    setCurrentTime(0);
    setActiveSegment(-1);
    setLastResult(null);
  }, []);

  const progress = exercise.duration > 0 ? (currentTime / exercise.duration) * 100 : 0;

  return (
    <div className="h-full flex flex-col">
      {/* Header */}
      <header className="flex items-center gap-3 px-4 py-3 border-b border-border shrink-0">
        <button onClick={onBack} className="p-1 -ml-1">
          <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
          </svg>
        </button>
        <div className="min-w-0 flex-1">
          <h2 className="text-sm font-medium truncate">{exercise.titleKo}</h2>
          <p className="text-xs text-muted-foreground">{exercise.categoryKo} Â· {segments.length}ê°œ êµ¬ê°„</p>
        </div>
      </header>

      {/* Timeline bar */}
      <div className="px-4 py-2 border-b border-border shrink-0">
        <div className="relative h-8 bg-muted rounded-full overflow-hidden">
          {/* Progress */}
          <div className="absolute inset-y-0 left-0 bg-primary/20 transition-all" style={{ width: `${progress}%` }} />
          
          {/* Segment markers */}
          {segments.map((seg, i) => {
            const left = (seg.end / exercise.duration) * 100;
            const score = segmentScores[i];
            return (
              <button
                key={i}
                onClick={() => jumpToSegment(i)}
                className="absolute top-1/2 -translate-y-1/2 -translate-x-1/2 z-10"
                style={{ left: `${left}%` }}
                title={`êµ¬ê°„ ${i + 1}`}
              >
                <div className={`w-3 h-3 rounded-full border-2 transition-all ${
                  i === activeSegment ? 'border-primary bg-primary scale-125' :
                  score !== undefined ? (score >= 4 ? 'border-emerald-500 bg-emerald-500' : score >= 3 ? 'border-amber-500 bg-amber-500' : 'border-red-400 bg-red-400') :
                  'border-muted-foreground/30 bg-background'
                }`} />
              </button>
            );
          })}

          {/* Playhead */}
          <div className="absolute top-0 bottom-0 w-0.5 bg-primary transition-all" style={{ left: `${progress}%` }} />
        </div>
        <div className="flex justify-between text-[10px] text-muted-foreground mt-1">
          <span>{formatTime(currentTime)}</span>
          <span>{formatTime(exercise.duration)}</span>
        </div>
      </div>

      {/* Main content */}
      <div className="flex-1 flex flex-col items-center justify-center px-6 overflow-y-auto">
        <AnimatePresence mode="wait">
          {/* IDLE */}
          {state === 'idle' && (
            <motion.div key="idle" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
              className="flex flex-col items-center gap-6 w-full max-w-sm"
            >
              <div className="w-20 h-20 rounded-full bg-muted flex items-center justify-center">
                <span className="text-3xl">ğŸ§</span>
              </div>
              <div className="text-center">
                <p className="text-sm text-muted-foreground">ìŒì„± ì¬ìƒ â†’ êµ¬ê°„ë§ˆë‹¤ ìë™ ë©ˆì¶¤ â†’ ë…¹ìŒ</p>
                <p className="text-xs text-muted-foreground mt-1">íƒ€ì„ë¼ì¸ì˜ ë§ˆì»¤ë¥¼ í´ë¦­í•´ì„œ ì›í•˜ëŠ” êµ¬ê°„ìœ¼ë¡œ ì´ë™</p>
              </div>
              <Button onClick={() => play(0)} size="lg" className="w-full max-w-xs">
                â–¶ ì¬ìƒ ì‹œì‘
              </Button>
            </motion.div>
          )}

          {/* PLAYING */}
          {state === 'playing' && (
            <motion.div key="playing" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
              className="flex flex-col items-center gap-4"
            >
              <motion.div
                animate={{ scale: [1, 1.05, 1] }}
                transition={{ repeat: Infinity, duration: 2 }}
                className="w-20 h-20 rounded-full bg-primary/10 flex items-center justify-center"
              >
                <span className="text-3xl">ğŸ”Š</span>
              </motion.div>
              <p className="text-sm font-medium">ì¬ìƒ ì¤‘... êµ¬ê°„ {activeSegment + 1}/{segments.length}</p>
              <Button variant="outline" size="sm" onClick={() => {
                audioRef.current?.pause();
                setState('paused');
                if (checkIntervalRef.current) clearInterval(checkIntervalRef.current);
              }}>
                â¸ ì¼ì‹œì •ì§€
              </Button>
            </motion.div>
          )}

          {/* PAUSED (auto-pause at segment boundary) */}
          {state === 'paused' && !lastResult && (
            <motion.div key="paused" initial={{ opacity: 0, y: 10 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0 }}
              className="flex flex-col items-center gap-4 w-full max-w-sm"
            >
              <div className="text-center">
                <p className="text-xs text-muted-foreground mb-1">êµ¬ê°„ {activeSegment + 1} / {segments.length}</p>
                <p className="text-sm font-medium">ì´ êµ¬ê°„ì—ì„œ ë…¹ìŒí• ê¹Œìš”?</p>
              </div>
              <div className="flex gap-3 w-full">
                <Button onClick={startRecording} size="lg" className="flex-1">
                  ğŸ™ï¸ ë…¹ìŒí•˜ê¸°
                </Button>
                <Button onClick={skipSegment} variant="outline" size="lg" className="flex-1">
                  ê±´ë„ˆë›°ê¸° â†’
                </Button>
              </div>
              <Button variant="ghost" size="sm" className="text-xs" onClick={() => {
                const seg = segments[activeSegment];
                if (seg) play(seg.start);
              }}>
                ğŸ”„ ì´ êµ¬ê°„ ë‹¤ì‹œ ë“£ê¸°
              </Button>
            </motion.div>
          )}

          {/* RECORDING */}
          {state === 'recording' && (
            <motion.div key="recording" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
              className="flex flex-col items-center gap-6 w-full max-w-sm"
            >
              <motion.div
                animate={{ scale: [1, 1.15, 1], boxShadow: ['0 0 0 0 rgba(239,68,68,0)', '0 0 0 20px rgba(239,68,68,0.1)', '0 0 0 0 rgba(239,68,68,0)'] }}
                transition={{ repeat: Infinity, duration: 1.5 }}
                className="w-20 h-20 rounded-full bg-red-50 flex items-center justify-center"
              >
                <span className="text-3xl">ğŸ™ï¸</span>
              </motion.div>
              <div className="text-center">
                <p className="text-sm font-medium text-red-600">ë…¹ìŒ ì¤‘</p>
                <p className="text-2xl font-mono font-bold mt-1">{recordingTime.toFixed(1)}s</p>
                {liveTranscript && (
                  <p className="text-xs text-muted-foreground mt-2 italic max-w-xs">
                    &ldquo;{liveTranscript}&rdquo;
                  </p>
                )}
              </div>
              <Button onClick={stopRecording} variant="destructive" size="lg" className="w-full max-w-xs">
                â¹ ë…¹ìŒ ì¤‘ì§€
              </Button>
            </motion.div>
          )}

          {/* REVIEWING (showing result for this segment) */}
          {(state === 'reviewing' || (state === 'paused' && lastResult)) && lastResult && (
            <motion.div key="review" initial={{ opacity: 0, y: 20 }} animate={{ opacity: 1, y: 0 }} exit={{ opacity: 0 }}
              className="flex flex-col items-center gap-4 w-full max-w-sm"
            >
              <Card className="w-full p-5">
                <div className="text-center mb-3">
                  <p className="text-xs text-muted-foreground">êµ¬ê°„ {activeSegment + 1} ê²°ê³¼</p>
                  <p className={`text-4xl font-bold ${
                    lastResult.scores.total >= 4 ? 'text-emerald-600' :
                    lastResult.scores.total >= 3 ? 'text-amber-600' : 'text-red-600'
                  }`}>{lastResult.scores.total.toFixed(1)}</p>
                </div>
                <div className="space-y-2">
                  {[
                    { label: 'ìœ ì°½ì„±', value: lastResult.scores.fluency, color: 'bg-blue-500' },
                    { label: 'ëª…ë£Œì„±', value: lastResult.scores.intelligibility, color: 'bg-emerald-500' },
                    { label: 'ì •í™•ë„', value: lastResult.scores.accuracy, color: 'bg-violet-500' },
                  ].map(s => (
                    <div key={s.label}>
                      <div className="flex justify-between text-xs mb-0.5">
                        <span className="text-muted-foreground">{s.label}</span>
                        <span className="font-medium">{s.value.toFixed(1)}</span>
                      </div>
                      <div className="h-1 bg-muted rounded-full overflow-hidden">
                        <motion.div
                          initial={{ width: 0 }}
                          animate={{ width: `${(s.value / 5) * 100}%` }}
                          transition={{ duration: 0.4 }}
                          className={`h-full rounded-full ${s.color}`}
                        />
                      </div>
                    </div>
                  ))}
                </div>
                <p className="text-xs text-center mt-3 text-muted-foreground">{lastResult.feedback}</p>
              </Card>
              {/* Diff display */}
              {(() => {
                const origTexts = transcriptsData[exercise.id];
                const origText = origTexts?.[activeSegment];
                if (origText && userTranscript) {
                  return (
                    <Card className="w-full p-4">
                      <p className="text-xs text-muted-foreground mb-2 font-medium">ë°œìŒ ë¹„êµ</p>
                      <DiffDisplay original={origText} spoken={userTranscript} />
                    </Card>
                  );
                }
                if (userTranscript) {
                  return (
                    <Card className="w-full p-4">
                      <p className="text-xs text-muted-foreground mb-1">ë‚´ê°€ ë§í•œ ê²ƒ</p>
                      <p className="text-sm">{userTranscript}</p>
                    </Card>
                  );
                }
                return null;
              })()}
              <div className="flex gap-3 w-full">
                <Button onClick={() => { setLastResult(null); startRecording(); }} variant="outline" className="flex-1 text-sm">
                  ë‹¤ì‹œ ë…¹ìŒ
                </Button>
                <Button onClick={continuePlayback} className="flex-1 text-sm">
                  ë‹¤ìŒ êµ¬ê°„ â†’
                </Button>
              </div>
            </motion.div>
          )}

          {/* FINISHED */}
          {state === 'finished' && (
            <motion.div key="finished" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}
              className="flex flex-col items-center gap-4 w-full max-w-sm"
            >
              <span className="text-5xl">ğŸ‰</span>
              <p className="text-sm font-medium">ì—°ìŠµ ì™„ë£Œ!</p>
              {Object.keys(segmentScores).length > 0 && (
                <p className="text-xs text-muted-foreground">
                  ë…¹ìŒ {Object.keys(segmentScores).length}ê°œ êµ¬ê°„ Â· í‰ê·  {(Object.values(segmentScores).reduce((a, b) => a + b, 0) / Object.keys(segmentScores).length).toFixed(1)}ì 
                </p>
              )}
              <div className="flex gap-3 w-full">
                <Button onClick={reset} variant="outline" className="flex-1">ì²˜ìŒë¶€í„°</Button>
                <Button onClick={onBack} className="flex-1">ëª©ë¡ìœ¼ë¡œ</Button>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>

      {/* Segment list (bottom) */}
      {state !== 'idle' && (
        <div className="border-t border-border px-4 py-2 shrink-0">
          <div className="flex gap-1.5 overflow-x-auto pb-1">
            {segments.map((_, i) => {
              const score = segmentScores[i];
              return (
                <button
                  key={i}
                  onClick={() => jumpToSegment(i)}
                  className={`shrink-0 w-8 h-8 rounded-md text-xs font-medium flex items-center justify-center transition-all ${
                    i === activeSegment ? 'bg-primary text-primary-foreground' :
                    score !== undefined ? (score >= 4 ? 'bg-emerald-100 text-emerald-700' : score >= 3 ? 'bg-amber-100 text-amber-700' : 'bg-red-100 text-red-700') :
                    'bg-muted text-muted-foreground'
                  }`}
                >
                  {score !== undefined ? score.toFixed(0) : i + 1}
                </button>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
}

function formatTime(seconds: number): string {
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60);
  return `${m}:${String(s).padStart(2, '0')}`;
}
